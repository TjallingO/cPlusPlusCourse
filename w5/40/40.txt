1. Pointer variables and arrays
Pointers and arrays are similar and can sometimes be used in place of the other, but are not the same. An array name will decay to a constant pointer to the location of the first element of the array, so it can be used in some pointer-like notation (i.e. << *(array + 5) = 10 >>). However, an array is a block of memory sized to fit the amount of objects matching its dimensions. In other words, declaring << int array[5]; >> allocates a block in memory that can hold 5 integers. As it is not initialised, for now that memory still contains the things that were there before. A pointer, on the other hand, is just that: a variable that stores the address of a memory location, i.e. it points towards a location. So although they are related concepts in C/C++, they are also very different.

2. Pointer variables and reference variables
See the drawing below (Figure 1).

3. Pointer arithmetic
It refers to the fact that as pointers store a memory location, which is just a numerical value, they can be used in calculations to traverse the memory. As such, the locations (i.e. values) in their close proximity may be relevant. For example, as explained, an array takes up a block of consecutive memory. So, incrementing a pointer will move it over the amount that is the size of its type (i.e. if p is a pointer to an integer, ++p will move it over the size of a single integer). An example of this can be found in Figure 1, part b, as well as in other exercises of this week. In the figure, << *(pointer[3] + 2) >> is equivalent to << array[3][2] >>, as well as << *(*(array + 3) + 2) >>, at least in their usage here. << *(array + 3) >> dereferences the location of the fourth row (i.e. accesses its actual value), and thus dereferencing that plus two accesses the third value within that row. As can be seen, these are pointers to the start of a block of memory, and knowing the type that is contained therein allows us to access specific elements in that block. In short, realising that pointers simply represent numerical values allows us to perform useful arithmetic with them.

4. Accessing an element in an array using only a pointer vs. index expression
Using a pointer will skip a step when accessing an element, which is to determine the size of the array element and add that to the address of the first element, which it also has to determine again and again. Since the index notation is simply a representation of operations that are actually performed, that is one reason to 'skip the middleman', as it were. Furthermore, adding another variable that has to be stored, used and incremented, namely a size_t as per the example in the exercise, further and unnecessarily adds to the size and weight of the program. Furthermore, given that an array name can decay to a pointer can add confusion to what kind of variable is actually being passed / used. Lastly, and similarly, using pointer notation makes it clear that the original data can be modified, rather than it being passed by value. However, as of yet, I still think index notation is more intuitive, but perhaps that will change over time.
